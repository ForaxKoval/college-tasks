# First exersize: 
Заповніть пропуски в реченнях:

**а)** Вказівник - це змінна, що в якості значення містить **адресу** іншої змінної.

**б)** Тільки три величини можуть бути використані для ініціалізації вказівника: **адреса**, **NULL**, або **0**.

**в)** Єдине ціле число, яке може бути присвоєне вказівнику це **0**


# Second exersize: 

Чи є наступні твердження вірними? Поясніть чому.

**a)** Операцію взяття адреси & можна застосовувати лише до констант, виразів і змінних, оголошених із модифікатором register.

**НЕВІРНО. Пояснення:** 
register — це модифікатор, який позначає змінну, яку компілятор зберігає в регістрі процесора для швидшого доступу. До таких змінних не можна застосовувати оператор &, оскільки вони не мають адреси в пам’яті.

**б)** Вказівник на void може бути розіменований.

**НЕВІРНО. Пояснення:** 
Оскільки void не має конкретного типу, то і компілятор не знає розміру його пам'яті (скільки у ньому байтів)

**в)** Вказівники на різні типи даних не можуть бути присвоєні один одному без використання операції приведення типів.

**ВІРНО. Пояснення:** 
Вказівники на різні типи даних не можна присвоювати один одному без явного приведення типів, оскільки вони можуть вказувати на дані різного розміру і комп’ютер буде по-різному їх читати.

# Third exersize: 

Припустимо, що числа з плаваючою комою звичайної точності займають 4 байти, і що початкова адреса масиву дорівнює 1002500.

**а)** Оголосіть масив numbers типу float з 10 елементів і присвойте елементам значення 0.0, 1.1, 2.2, …, 9.9. Використовуйте символічну константу SIZE, що дорівнює 10.

```
    const int SIZE = 10;
    float numbers[SIZE];
    for (int i = 0; i < SIZE; i++) {
        numbers[i] = i * 1.1f;
    }
```

**б)** Оголосіть вказівник pPtr, який посилається на тип float.
```
float *pPtr;
```

**в)** Виведіть елементи масиву numbers, використовуючи нотацію ім’я масиву/індекс. Використайте цикл for і змінну циклу i. Виводьте кожен елемент з точністю до одного знака після коми.
```
 for (int i = 0; i < SIZE; i++) {
        printf("%.1f ", numbers[i]);
}
```
**г)** Присвойте вказівнику pPtr адресу початку масиву numbers двома способами.
```
pPtr = numbers;
    OR
pPtr = &numbers[0];
```

**ґ)** Виведіть елементи масиву numbers, використовуючи доступ до елементів за схемою вказівник/зміщення, де як вказівник використовується pPtr.
```
for (int i = 0; i < SIZE; i++) {
    printf("%.1f ", *(pPtr + i));
}
```
**д)** Виведіть елементи масиву numbers, використовуючи доступ до елементів за схемою вказівник/зміщення, де як вказівник використовується ім’я масиву.
```
for (int i = 0; i < SIZE; i++) {
    printf("%.1f ", *(numbers + i));
}
```
**е)** Виведіть елементи масиву numbers, використовуючи індексацію вказівника pPtr.
```
for (int i = 0; i < SIZE; i++) {
    printf("%.1f ", pPtr[i]);
}
```
**є)** Зверніться до четвертого елемента масиву, використовуючи всі чотири способи доступу до елементів масиву:
```
numbers[3];       // ім’я масиву/індекс
*(numbers + 3);   // ім’я масиву/зміщення
pPtr[3];          // вказівник/індекс з вказівником pPtr
*(pPtr + 3);      // вказівник/зміщення з вказівником pPtr
3[pPtr];          // зміщення/вказівник з вказівником pPtr
*(pPtr + 3);      // індекс/вказівник з вказівником pPtr
```

**ж)** Якщо припустити, що pPtr вказує на початок масиву numbers, то на яку адресу посилається вираз pPtr + 8? Яке значення знаходиться за цією адресою? 
```
Вираз pPtr + 8 посилається на адресу 1002500 + (8 * 4)
Значення - numbers[8] = 8 * 1.1 = 8.8
```
**з)** Припустимо, що pPtr посилається на numbers[5]. На яку адресу посилається вираз pPtr - 4? Яке значення знаходиться за цією адресою?
```
Оскільки numbers[5] = 1002500 + 5*4 = 1002520
То вираз pPtr - 4 посилається на адресу  1002520 - 4 × 4 = 1002504
Значення за цією адресою = numbers[1] = 1.1
```